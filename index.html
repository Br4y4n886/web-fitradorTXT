<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Buscador en archivos grandes (stream)</title>
<!-- SheetJS (xlsx) para exportar a Excel -->
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<style>
  body { font-family: Arial, sans-serif; background:#f4f6f8; color:#222; padding:20px; max-width:1000px; margin:auto; }
  .card { background:#fff; border-radius:10px; padding:20px; box-shadow:0 2px 10px rgba(0,0,0,0.08); }
  h1{color:#065a9d;text-align:center}
  label{display:block;margin-top:12px;font-weight:600}
  input[type="text"], input[type="file"], button { width:100%; padding:10px; border-radius:6px; border:1px solid #ccc; box-sizing:border-box; }
  .btn { background:#065a9d;color:#fff;border:none;cursor:pointer;padding:12px;border-radius:8px;font-size:16px }
  .btn:disabled{background:#999;cursor:not-allowed}
  .row{display:flex;gap:10px;margin-top:10px}
  .small{font-size:13px;color:#555}
  #resultados{ margin-top:16px; padding:12px; background:#fafafa;border-radius:6px; border:1px solid #e6e6e6; max-height:420px; overflow:auto; white-space:pre-wrap; }
  mark{ background: #ffeb3b; font-weight:700; color:#000 }
  .line{ padding:6px 8px; border-bottom:1px solid #eee; font-family:monospace; font-size:13px }
  #progreso{ width:100%; height:16px; }
  .controls { display:flex; gap:8px; margin-top:10px; flex-wrap:wrap; }
  .meta { margin-top:10px; font-size:14px; }
  .notice { margin-top:8px; color:#b55; font-weight:600 }
</style>
</head>
<body>
  <h1>🔎 Buscador de texto (archivos grandes)</h1>
  <div class="card">
    <label for="archivo">Selecciona un archivo (.txt, .log...)</label>
    <input id="archivo" type="file" accept=".txt,.log,.log.txt" multiple>

    <label for="frase">Frase a buscar</label>
    <input id="frase" type="text" placeholder="Ej: IdQuote creado: 0">

    <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
      <input id="mostrarTodas" type="checkbox" style="width:unset">
      <label for="mostrarTodas" style="margin:0;font-weight:400">Mostrar todas las coincidencias (puede tardar mucho)</label>
    </div>

    <div class="controls">
      <button id="btnBuscar" class="btn" disabled>🔍 Buscar</button>
      <button id="btnCancelar" class="btn" style="background:#c0392b;display:none">✖️ Cancelar</button>
      <button id="btnDescargar" class="btn" style="background:#27ae60;display:none">⬇️ Descargar coincidencias</button>
      <button id="btnExcel" class="btn" style="background:#229954;display:none">📊 Descargar Excel</button>
    </div>

    <progress id="progreso" value="0" max="100" style="display:block;margin-top:12px"></progress>
    <div id="status" class="meta">Estado: esperando archivo...</div>
    <div id="contador" class="meta"></div>
    <div id="resultados"></div>
    <div id="notice" class="notice" style="display:none"></div>
  </div>

<script>
(function(){
  const fileInput = document.getElementById('archivo');
  const fraseInput = document.getElementById('frase');
  const btnBuscar = document.getElementById('btnBuscar');
  const btnCancelar = document.getElementById('btnCancelar');
  const btnDescargar = document.getElementById('btnDescargar');

  const progreso = document.getElementById('progreso');
  const status = document.getElementById('status');
  const contadorEl = document.getElementById('contador');
  const resultadosEl = document.getElementById('resultados');
  const mostrarTodasCheckbox = document.getElementById('mostrarTodas');
  const noticeEl = document.getElementById('notice');
  const btnExcel = document.getElementById('btnExcel');

  let abortRequested = false;
  let downloadBlobUrl = null;

  fileInput.addEventListener('change', () => {
    btnBuscar.disabled = !fileInput.files.length;
    resultadosEl.innerHTML = '';
    contadorEl.textContent = '';
    noticeEl.style.display = 'none';
    progreso.value = 0;
    if (fileInput.files.length === 1) {
      status.textContent = `Archivo seleccionado: ${fileInput.files[0].name} (${(fileInput.files[0].size/1024/1024).toFixed(2)} MB)`;
    } else if (fileInput.files.length > 1) {
      let total = 0;
      for (let f of fileInput.files) total += f.size;
      status.textContent = `Archivos seleccionados: ${fileInput.files.length} (${(total/1024/1024).toFixed(2)} MB)`;
    } else {
      status.textContent = 'Estado: esperando archivo...';
    }
  });

  btnBuscar.addEventListener('click', async () => {
    const files = Array.from(fileInput.files);
    const phrase = fraseInput.value.trim();
    if(!files.length) { alert('Selecciona al menos un archivo'); return; }
    if(!phrase) { alert('Escribe una frase a buscar'); return; }

    // ajustar límite de visualización (evitar bloquear)
    const showAll = mostrarTodasCheckbox.checked;
    const maxDisplay = showAll ? Infinity : 5000; // por defecto 5000 líneas mostradas

    // iniciar procesamiento
    abortRequested = false;
    btnBuscar.disabled = true;
    fileInput.disabled = true;
    btnCancelar.style.display = 'inline-block';
    btnDescargar.style.display = 'none';
    btnExcel.style.display = 'none';
    resultadosEl.innerHTML = '';
    contadorEl.textContent = 'Coincidencias: 0';
    status.textContent = 'Iniciando lectura...';
    noticeEl.style.display = 'none';
    progreso.value = 0;

    let totalMatches = 0;
    let allMatchesForDownload = [];
    let allMatchesForExcel = [];
    let totalSize = files.reduce((a, f) => a + f.size, 0);
    let processedSize = 0;
    for (let idx = 0; idx < files.length; idx++) {
      const file = files[idx];
      status.textContent = `Procesando archivo ${idx+1} de ${files.length}: ${file.name}`;
      // Llamar a processLargeFile, pero ahora pasamos el nombre del archivo
      const { matchesCount, matchesForDownload, matchesForExcel, bytesRead } = await processLargeFile(file, phrase, {maxDisplay, offsetSize: processedSize, totalSize});
      processedSize += file.size;
      totalMatches += matchesCount;
      // Para TXT: guardar como "archivo: línea"
      allMatchesForDownload.push(...matchesForDownload.map(line => `${file.name}: ${line}`));
      // Para Excel: guardar como [archivo, línea]
      allMatchesForExcel.push(...matchesForExcel.map(line => [file.name, line]));
    }
    status.textContent = abortRequested ? 'Proceso cancelado' : 'Lectura finalizada';
    contadorEl.textContent = `Coincidencias encontradas: ${totalMatches} (líneas)`;
    btnBuscar.disabled = false;
    fileInput.disabled = false;
    btnCancelar.style.display = 'none';
    if (allMatchesForDownload.length > 0) {
      // preparar blob para descarga
      const blob = new Blob([allMatchesForDownload.join("\n")], {type:'text/plain;charset=utf-8'});
      if (downloadBlobUrl) URL.revokeObjectURL(downloadBlobUrl);
      downloadBlobUrl = URL.createObjectURL(blob);
      btnDescargar.style.display = 'inline-block';
      btnDescargar.onclick = () => {
        const a = document.createElement('a');
        a.href = downloadBlobUrl;
        a.download = 'resultados.matches.txt';
        a.click();
      };
      // Mostrar botón Excel
      btnExcel.style.display = 'inline-block';
      btnExcel.onclick = () => {
        exportarExcel(allMatchesForExcel);
      };
    } else {
      btnDescargar.style.display = 'none';
      btnExcel.style.display = 'none';
    }
  });

  // Exportar resultados a Excel usando SheetJS
  function exportarExcel(datos) {
    // datos: array de [archivo, coincidencia]
    const rows = datos;
    rows.unshift(['Archivo', 'Coincidencia']);
    const ws = XLSX.utils.aoa_to_sheet(rows);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Resultados');
    XLSX.writeFile(wb, 'resultados.matches.xlsx');
  }

  btnCancelar.addEventListener('click', () => {
    abortRequested = true;
    status.textContent = 'Cancelando...';
    btnCancelar.disabled = true;
  });

  // Función principal: intenta usar stream (si está disponible), si no, usa slices
  async function processLargeFile(file, phrase, opts = {}) {
    const phraseLower = phrase.toLowerCase();
    const isStreamSupported = !!(file.stream && file.stream().getReader);
    let matchesCount = 0;
    let displayedCount = 0;
    const matchesForDownload = []; // guardamos líneas originales para descarga (para TXT)
    const matchesForExcel = [];    // para Excel: solo la línea, el nombre de archivo se agrega fuera
    const batch = [];
    const batchRenderSize = 200; // renderizar cada 200 líneas para no bloquear

    const escapeHtml = s => s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');

    const highlightLine = (line, phraseLen) => {
      // construimos la línea escapada con <mark> alrededor de cada coincidencia (insensible mayúsc/minúsc)
      const low = line.toLowerCase();
      const p = phraseLower;
      let idx = 0;
      let prev = 0;
      let out = '';
      while ((idx = low.indexOf(p, prev)) !== -1) {
        out += escapeHtml(line.slice(prev, idx));
        out += '<mark>' + escapeHtml(line.slice(idx, idx + phraseLen)) + '</mark>';
        prev = idx + phraseLen;
      }
      out += escapeHtml(line.slice(prev));
      return out;
    };

    const appendBatchToDOM = (batchArr) => {
      if (batchArr.length === 0) return;
      const frag = document.createDocumentFragment();
      for (let htmlLine of batchArr) {
        const div = document.createElement('div');
        div.className = 'line';
        div.innerHTML = htmlLine;
        frag.appendChild(div);
      }
      resultadosEl.appendChild(frag);
      // mantener scroll abajo si se está al final
      // resultadosEl.scrollTop = resultadosEl.scrollHeight;
    };

    // procesa array de líneas (no incluyen la última parcial)
    const processLines = (lines) => {
      for (let line of lines) {
        if (abortRequested) return;
        const lower = line.toLowerCase();
        if (lower.indexOf(phraseLower) !== -1) {
          matchesCount++;
          matchesForDownload.push(line); // para TXT
          matchesForExcel.push(line);    // para Excel
          if (displayedCount < opts.maxDisplay) {
            // Mostrar en DOM: incluir nombre de archivo
            const highlighted = `<span style='color:#888'>[${escapeHtml(file.name)}]</span> ` + highlightLine(line, phraseLower.length);
            batch.push(highlighted);
            displayedCount++;
            if (batch.length >= batchRenderSize) {
              appendBatchToDOM(batch.splice(0, batch.length));
            }
          }
        }
      }
      // render remaining small batch if any
      if (batch.length >= batchRenderSize) {
        appendBatchToDOM(batch.splice(0, batch.length));
      }
      // actualizar contador en UI
      contadorEl.textContent = `Coincidencias encontradas: ${matchesCount}`;
    };

    let bytesRead = 0;
    if (isStreamSupported) {
      status.textContent = 'Leyendo mediante stream (método rápido)...';
      const reader = file.stream().getReader();
      const decoder = new TextDecoder();
      let remainder = '';
      try {
        while (true) {
          if (abortRequested) { await reader.cancel(); break; }
          const {value, done} = await reader.read();
          if (done) break;
          bytesRead += value.byteLength;
          const chunkText = decoder.decode(value, {stream: true});
          const text = remainder + chunkText;
          const lines = text.split(/\r?\n/);
          remainder = lines.pop() || '';
          processLines(lines);
          // actualizar progreso global si se procesan varios archivos
          if (opts.totalSize) {
            progreso.value = Math.min(100, Math.round(((opts.offsetSize + bytesRead) / opts.totalSize) * 100));
          } else {
            progreso.value = Math.min(100, Math.round((bytesRead / file.size) * 100));
          }
          status.textContent = `Leyendo... ${(((opts.offsetSize||0)+bytesRead)/1024/1024).toFixed(2)} MB / ${((opts.totalSize?opts.totalSize:file.size)/1024/1024).toFixed(2)} MB`;
          if (matchesForDownload.length > opts.maxDisplay && isFinite(opts.maxDisplay) && !mostrarTodasCheckbox.checked) {
            noticeEl.style.display = 'block';
            noticeEl.textContent = `Se muestran las primeras ${opts.maxDisplay} coincidencias. Activa "Mostrar todas" si deseas ver todas (puede tardar y usar mucha memoria).`;
          }
        }
        if (!abortRequested && remainder) {
          processLines([remainder]);
        }
        if (batch.length) appendBatchToDOM(batch.splice(0, batch.length));
        if (opts.totalSize) {
          progreso.value = Math.min(100, Math.round(((opts.offsetSize + file.size) / opts.totalSize) * 100));
        } else {
          progreso.value = 100;
        }
      } finally {
        try { reader.releaseLock && reader.releaseLock(); } catch(e){}
      }
    } else {
      // Fallback: leer en slices
      status.textContent = 'Leyendo por slices (fallback)...';
      const chunkSize = 2 * 1024 * 1024; // 2MB
      let offset = 0;
      let remainder = '';
      while (offset < file.size) {
        if (abortRequested) break;
        const chunk = file.slice(offset, offset + chunkSize);
        const chunkText = await readBlobAsText(chunk);
        const text = remainder + chunkText;
        const lines = text.split(/\r?\n/);
        remainder = lines.pop() || '';
        processLines(lines);
        offset += chunk.size;
        bytesRead = offset;
        if (opts.totalSize) {
          progreso.value = Math.min(100, Math.round(((opts.offsetSize + offset) / opts.totalSize) * 100));
        } else {
          progreso.value = Math.min(100, Math.round((offset / file.size) * 100));
        }
        status.textContent = `Leyendo... ${(((opts.offsetSize||0)+offset)/1024/1024).toFixed(2)} MB / ${((opts.totalSize?opts.totalSize:file.size)/1024/1024).toFixed(2)} MB`;
        if (matchesForDownload.length > opts.maxDisplay && isFinite(opts.maxDisplay) && !mostrarTodasCheckbox.checked) {
          noticeEl.style.display = 'block';
          noticeEl.textContent = `Se muestran las primeras ${opts.maxDisplay} coincidencias. Activa "Mostrar todas" si deseas ver todas (puede tardar y usar mucha memoria).`;
        }
      }
      if (!abortRequested && remainder) processLines([remainder]);
      if (batch.length) appendBatchToDOM(batch.splice(0, batch.length));
      if (opts.totalSize) {
        progreso.value = Math.min(100, Math.round(((opts.offsetSize + file.size) / opts.totalSize) * 100));
      } else {
        progreso.value = 100;
      }
    }

    if (abortRequested) {
      noticeEl.style.display = 'block';
      noticeEl.textContent = 'Búsqueda cancelada por el usuario.';
    } else {
      if (matchesForDownload.length === 0) {
        status.textContent = 'No se encontraron coincidencias.';
      } else {
        status.textContent = 'Búsqueda completada.';
        if (!mostrarTodasCheckbox.checked && isFinite(opts.maxDisplay) && matchesForDownload.length > opts.maxDisplay) {
          noticeEl.style.display = 'block';
          noticeEl.textContent = `Resultados truncados a ${opts.maxDisplay} líneas para evitar congelar el navegador.`;
        } else {
          noticeEl.style.display = 'none';
        }
      }
    }

    return { matchesCount, matchesForDownload, matchesForExcel, bytesRead };
  }

  function readBlobAsText(blob) {
    return new Promise((resolve, reject) => {
      const fr = new FileReader();
      fr.onload = e => resolve(e.target.result);
      fr.onerror = e => reject(e);
      fr.readAsText(blob);
    });
  }

})();
</script>
</body>
</html>
