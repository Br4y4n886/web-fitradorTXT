<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Buscador en archivos grandes (stream)</title>
<!-- SheetJS (xlsx) para exportar a Excel -->
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<style>
  body { font-family: Arial, sans-serif; background:#f4f6f8; color:#222; padding:20px; max-width:1000px; margin:auto; }
  .card { background:#fff; border-radius:10px; padding:20px; box-shadow:0 2px 10px rgba(0,0,0,0.08); }
  h1{color:#065a9d;text-align:center}
  label{display:block;margin-top:12px;font-weight:600}
  input[type="text"], input[type="file"], button { width:100%; padding:10px; border-radius:6px; border:1px solid #ccc; box-sizing:border-box; }
  .btn { background:#065a9d;color:#fff;border:none;cursor:pointer;padding:12px;border-radius:8px;font-size:16px }
  .btn:disabled{background:#999;cursor:not-allowed}
  .row{display:flex;gap:10px;margin-top:10px}
  .small{font-size:13px;color:#555}
  #resultados{ margin-top:16px; padding:12px; background:#fafafa;border-radius:6px; border:1px solid #e6e6e6; max-height:420px; overflow:auto; white-space:pre-wrap; }
  mark{ background: #ffeb3b; font-weight:700; color:#000 }
  .line{ padding:6px 8px; border-bottom:1px solid #eee; font-family:monospace; font-size:13px }
  #progreso{ width:100%; height:16px; }
  .controls { display:flex; gap:8px; margin-top:10px; flex-wrap:wrap; }
  .meta { margin-top:10px; font-size:14px; }
  .notice { margin-top:8px; color:#b55; font-weight:600 }
</style>
</head>
<body>
  <h1>🔎 Buscador de texto (archivos grandes)</h1>
  <div class="card">
    <label for="archivo">Selecciona un archivo (.txt, .log...)</label>
    <input id="archivo" type="file" accept=".txt,.log,.log.txt" multiple>

    <label for="frase">Frase a buscar</label>
    <input id="frase" type="text" placeholder="Ej: IdQuote creado: 0">

    <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
      <input id="mostrarTodas" type="checkbox" style="width:unset">
      <label for="mostrarTodas" style="margin:0;font-weight:400">Mostrar todas las coincidencias (puede tardar mucho)</label>
    </div>

    <div class="controls">
      <button id="btnBuscar" class="btn" disabled>🔍 Buscar</button>
      <button id="btnCancelar" class="btn" style="background:#c0392b;display:none">✖️ Cancelar</button>
      <button id="btnDescargar" class="btn" style="background:#27ae60;display:none">⬇️ Descargar coincidencias</button>
      <button id="btnExcel" class="btn" style="background:#229954;display:none">📊 Descargar Excel</button>
      <button id="btnBuscarParecidas" class="btn" style="background:#8e44ad;">🔎 Buscar líneas parecidas</button>
    </div>

    <progress id="progreso" value="0" max="100" style="display:block;margin-top:12px"></progress>
    <div id="status" class="meta">Estado: esperando archivo...</div>
    <div id="contador" class="meta"></div>
    <div id="resultados"></div>
    <div id="parecidas"></div>
    <div id="paginadoParecidas" style="margin:16px 0;text-align:center;"></div>
    <div id="notice" class="notice" style="display:none"></div>
  </div>

<script>
(function(){
  const fileInput = document.getElementById('archivo');
  const fraseInput = document.getElementById('frase');
  const btnBuscar = document.getElementById('btnBuscar');
  const btnCancelar = document.getElementById('btnCancelar');
  const btnDescargar = document.getElementById('btnDescargar');
  const btnBuscarParecidas = document.getElementById('btnBuscarParecidas');
  const parecidasEl = document.getElementById('parecidas');
  const paginadoParecidasEl = document.getElementById('paginadoParecidas');
  const resultadosEl = document.getElementById('resultados');
  const contadorEl = document.getElementById('contador');
  const noticeEl = document.getElementById('notice');
  const progreso = document.getElementById('progreso');
  const status = document.getElementById('status');
  const btnExcel = document.getElementById('btnExcel');
  const mostrarTodasCheckbox = document.getElementById('mostrarTodas');

  let gruposParecidas = [];
  let paginaActualParecidas = 1;
  const gruposPorPagina = 100;

  let abortRequested = false;
  let downloadBlobUrl = null;

  fileInput.addEventListener('change', () => {
    btnBuscar.disabled = !fileInput.files.length;
    resultadosEl.innerHTML = '';
    contadorEl.textContent = '';
    noticeEl.style.display = 'none';
    progreso.value = 0;
    if (fileInput.files.length === 1) {
      status.textContent = `Archivo seleccionado: ${fileInput.files[0].name} (${(fileInput.files[0].size/1024/1024).toFixed(2)} MB)`;
    } else if (fileInput.files.length > 1) {
      let total = 0;
      for (let f of fileInput.files) total += f.size;
      status.textContent = `Archivos seleccionados: ${fileInput.files.length} (${(total/1024/1024).toFixed(2)} MB)`;
    } else {
      status.textContent = 'Estado: esperando archivo...';
    }
  });

  btnBuscar.addEventListener('click', async () => {
    const files = Array.from(fileInput.files);
    const phrase = fraseInput.value.trim();
    if(!files.length) { alert('Selecciona al menos un archivo'); return; }
    if(!phrase) { alert('Escribe una frase a buscar'); return; }

    // ajustar límite de visualización (evitar bloquear)
    const showAll = mostrarTodasCheckbox.checked;
    const maxDisplay = showAll ? Infinity : 5000; // por defecto 5000 líneas mostradas

    // iniciar procesamiento
    abortRequested = false;
    btnBuscar.disabled = true;
    fileInput.disabled = true;
    btnCancelar.style.display = 'inline-block';
    btnDescargar.style.display = 'none';
    btnExcel.style.display = 'none';
    resultadosEl.innerHTML = '';
    contadorEl.textContent = 'Coincidencias: 0';
    status.textContent = 'Iniciando lectura...';
    noticeEl.style.display = 'none';
    progreso.value = 0;

    let totalMatches = 0;
    let allMatchesForDownload = [];
    let allMatchesForExcel = [];
    let totalSize = files.reduce((a, f) => a + f.size, 0);
    let processedSize = 0;
    for (let idx = 0; idx < files.length; idx++) {
      const file = files[idx];
      status.textContent = `Procesando archivo ${idx+1} de ${files.length}: ${file.name}`;
      // Llamar a processLargeFile, pero ahora pasamos el nombre del archivo
      const { matchesCount, matchesForDownload, matchesForExcel, bytesRead } = await processLargeFile(file, phrase, {maxDisplay, offsetSize: processedSize, totalSize});
      processedSize += file.size;
      totalMatches += matchesCount;
      // Para TXT: guardar como "archivo: línea"
      allMatchesForDownload.push(...matchesForDownload.map(line => `${file.name}: ${line}`));
      // Para Excel: guardar como [archivo, línea]
      allMatchesForExcel.push(...matchesForExcel.map(line => [file.name, line]));
    }
    status.textContent = abortRequested ? 'Proceso cancelado' : 'Lectura finalizada';
    contadorEl.textContent = `Coincidencias encontradas: ${totalMatches} (líneas)`;
    btnBuscar.disabled = false;
    fileInput.disabled = false;
    btnCancelar.style.display = 'none';
    if (allMatchesForDownload.length > 0) {
      // preparar blob para descarga
      const blob = new Blob([allMatchesForDownload.join("\n")], {type:'text/plain;charset=utf-8'});
      if (downloadBlobUrl) URL.revokeObjectURL(downloadBlobUrl);
      downloadBlobUrl = URL.createObjectURL(blob);
      btnDescargar.style.display = 'inline-block';
      btnDescargar.onclick = () => {
        const a = document.createElement('a');
        a.href = downloadBlobUrl;
        a.download = 'resultados.matches.txt';
        a.click();
      };
      // Mostrar botón Excel
      btnExcel.style.display = 'inline-block';
      btnExcel.onclick = () => {
        exportarExcel(allMatchesForExcel);
      };
    } else {
      btnDescargar.style.display = 'none';
      btnExcel.style.display = 'none';
    }
  });

  // Exportar resultados a Excel usando SheetJS
  function exportarExcel(datos) {
    // datos: array de [archivo, coincidencia]
    const rows = datos;
    rows.unshift(['Archivo', 'Coincidencia']);
    const ws = XLSX.utils.aoa_to_sheet(rows);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Resultados');
    XLSX.writeFile(wb, 'resultados.matches.xlsx');
  }

  btnCancelar.addEventListener('click', () => {
    abortRequested = true;
    status.textContent = 'Cancelando...';
    btnCancelar.disabled = true;
  });

  // Función principal: intenta usar stream (si está disponible), si no, usa slices
  async function processLargeFile(file, phrase, opts = {}) {
    const phraseLower = phrase.toLowerCase();
    const isStreamSupported = !!(file.stream && file.stream().getReader);
    let matchesCount = 0;
    let displayedCount = 0;
    const matchesForDownload = []; // guardamos líneas originales para descarga (para TXT)
    const matchesForExcel = [];    // para Excel: solo la línea, el nombre de archivo se agrega fuera
    const batch = [];
    const batchRenderSize = 200; // renderizar cada 200 líneas para no bloquear

    const escapeHtml = s => s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');

    const highlightLine = (line, phraseLen) => {
      // construimos la línea escapada con <mark> alrededor de cada coincidencia (insensible mayúsc/minúsc)
      const low = line.toLowerCase();
      const p = phraseLower;
      let idx = 0;
      let prev = 0;
      let out = '';
      while ((idx = low.indexOf(p, prev)) !== -1) {
        out += escapeHtml(line.slice(prev, idx));
        out += '<mark>' + escapeHtml(line.slice(idx, idx + phraseLen)) + '</mark>';
        prev = idx + phraseLen;
      }
      out += escapeHtml(line.slice(prev));
      return out;
    };

    const appendBatchToDOM = (batchArr) => {
      if (batchArr.length === 0) return;
      const frag = document.createDocumentFragment();
      for (let htmlLine of batchArr) {
        const div = document.createElement('div');
        div.className = 'line';
        div.innerHTML = htmlLine;
        frag.appendChild(div);
      }
      resultadosEl.appendChild(frag);
      // mantener scroll abajo si se está al final
      // resultadosEl.scrollTop = resultadosEl.scrollHeight;
    };

    // procesa array de líneas (no incluyen la última parcial)
    const processLines = (lines) => {
      for (let line of lines) {
        if (abortRequested) return;
        const lower = line.toLowerCase();
        if (lower.indexOf(phraseLower) !== -1) {
          matchesCount++;
          matchesForDownload.push(line); // para TXT
          matchesForExcel.push(line);    // para Excel
          if (displayedCount < opts.maxDisplay) {
            // Mostrar en DOM: incluir nombre de archivo
            const highlighted = `<span style='color:#888'>[${escapeHtml(file.name)}]</span> ` + highlightLine(line, phraseLower.length);
            batch.push(highlighted);
            displayedCount++;
            if (batch.length >= batchRenderSize) {
              appendBatchToDOM(batch.splice(0, batch.length));
            }
          }
        }
      }
      // render remaining small batch if any
      if (batch.length >= batchRenderSize) {
        appendBatchToDOM(batch.splice(0, batch.length));
      }
      // actualizar contador en UI
      contadorEl.textContent = `Coincidencias encontradas: ${matchesCount}`;
    };

    let bytesRead = 0;
    if (isStreamSupported) {
      status.textContent = 'Leyendo mediante stream (método rápido)...';
      const reader = file.stream().getReader();
      const decoder = new TextDecoder();
      let remainder = '';
      try {
        while (true) {
          if (abortRequested) { await reader.cancel(); break; }
          const {value, done} = await reader.read();
          if (done) break;
          bytesRead += value.byteLength;
          const chunkText = decoder.decode(value, {stream: true});
          const text = remainder + chunkText;
          const lines = text.split(/\r?\n/);
          remainder = lines.pop() || '';
          processLines(lines);
          // actualizar progreso global si se procesan varios archivos
          if (opts.totalSize) {
            progreso.value = Math.min(100, Math.round(((opts.offsetSize + bytesRead) / opts.totalSize) * 100));
          } else {
            progreso.value = Math.min(100, Math.round((bytesRead / file.size) * 100));
          }
          status.textContent = `Leyendo... ${(((opts.offsetSize||0)+bytesRead)/1024/1024).toFixed(2)} MB / ${((opts.totalSize?opts.totalSize:file.size)/1024/1024).toFixed(2)} MB`;
          if (matchesForDownload.length > opts.maxDisplay && isFinite(opts.maxDisplay) && !mostrarTodasCheckbox.checked) {
            noticeEl.style.display = 'block';
            noticeEl.textContent = `Se muestran las primeras ${opts.maxDisplay} coincidencias. Activa "Mostrar todas" si deseas ver todas (puede tardar y usar mucha memoria).`;
          }
        }
        if (!abortRequested && remainder) {
          processLines([remainder]);
        }
        if (batch.length) appendBatchToDOM(batch.splice(0, batch.length));
        if (opts.totalSize) {
          progreso.value = Math.min(100, Math.round(((opts.offsetSize + file.size) / opts.totalSize) * 100));
        } else {
          progreso.value = 100;
        }
      } finally {
        try { reader.releaseLock && reader.releaseLock(); } catch(e){}
      }
    } else {
      // Fallback: leer en slices
      status.textContent = 'Leyendo por slices (fallback)...';
      const chunkSize = 2 * 1024 * 1024; // 2MB
      let offset = 0;
      let remainder = '';
      while (offset < file.size) {
        if (abortRequested) break;
        const chunk = file.slice(offset, offset + chunkSize);
        const chunkText = await readBlobAsText(chunk);
        const text = remainder + chunkText;
        const lines = text.split(/\r?\n/);
        remainder = lines.pop() || '';
        processLines(lines);
        offset += chunk.size;
        bytesRead = offset;
        if (opts.totalSize) {
          progreso.value = Math.min(100, Math.round(((opts.offsetSize + offset) / opts.totalSize) * 100));
        } else {
          progreso.value = Math.min(100, Math.round((offset / file.size) * 100));
        }
        status.textContent = `Leyendo... ${(((opts.offsetSize||0)+offset)/1024/1024).toFixed(2)} MB / ${((opts.totalSize?opts.totalSize:file.size)/1024/1024).toFixed(2)} MB`;
        if (matchesForDownload.length > opts.maxDisplay && isFinite(opts.maxDisplay) && !mostrarTodasCheckbox.checked) {
          noticeEl.style.display = 'block';
          noticeEl.textContent = `Se muestran las primeras ${opts.maxDisplay} coincidencias. Activa "Mostrar todas" si deseas ver todas (puede tardar y usar mucha memoria).`;
        }
      }
      if (!abortRequested && remainder) processLines([remainder]);
      if (batch.length) appendBatchToDOM(batch.splice(0, batch.length));
      if (opts.totalSize) {
        progreso.value = Math.min(100, Math.round(((opts.offsetSize + file.size) / opts.totalSize) * 100));
      } else {
        progreso.value = 100;
      }
    }

    if (abortRequested) {
      noticeEl.style.display = 'block';
      noticeEl.textContent = 'Búsqueda cancelada por el usuario.';
    } else {
      if (matchesForDownload.length === 0) {
        status.textContent = 'No se encontraron coincidencias.';
      } else {
        status.textContent = 'Búsqueda completada.';
        if (!mostrarTodasCheckbox.checked && isFinite(opts.maxDisplay) && matchesForDownload.length > opts.maxDisplay) {
          noticeEl.style.display = 'block';
          noticeEl.textContent = `Resultados truncados a ${opts.maxDisplay} líneas para evitar congelar el navegador.`;
        } else {
          noticeEl.style.display = 'none';
        }
      }
    }

    return { matchesCount, matchesForDownload, matchesForExcel, bytesRead };
  }

  function readBlobAsText(blob) {
    return new Promise((resolve, reject) => {
      const fr = new FileReader();
      fr.onload = e => resolve(e.target.result);
      fr.onerror = e => reject(e);
      fr.readAsText(blob);
    });
  }

  btnBuscarParecidas.addEventListener('click', async () => {
    const files = Array.from(fileInput.files);
    if(!files.length) { alert('Selecciona al menos un archivo'); return; }
    btnBuscarParecidas.disabled = true;
    parecidasEl.innerHTML = '<b>Analizando líneas parecidas...</b>';
    paginadoParecidasEl.innerHTML = '';
    progreso.value = 0;
    progreso.style.display = 'block';
    let allLines = [];
    for (let file of files) {
      const text = await readBlobAsText(file);
      const lines = text.split(/\r?\n/).map(l => l.trim()).filter(l => l.length > 0);
      for (let line of lines) {
        allLines.push({file: file.name, raw: line, norm: normalizarLinea(line)});
      }
    }
    // Comparar todas las líneas entre sí (O(n^2), pero con barra de progreso)
    let grupos = [];
    let usado = new Array(allLines.length).fill(false);
    let comparaciones = allLines.length * (allLines.length-1) / 2;
    let hechas = 0;
    for (let i = 0; i < allLines.length; i++) {
      if (usado[i]) continue;
      let grupo = [allLines[i]];
      for (let j = i+1; j < allLines.length; j++) {
        if (usado[j]) continue;
        if (sonSimilares(allLines[i].norm, allLines[j].norm)) {
          grupo.push(allLines[j]);
          usado[j] = true;
        }
        hechas++;
        if (hechas % 500 === 0) {
          progreso.value = Math.round((hechas/comparaciones)*100);
        }
      }
      if (grupo.length > 1) grupos.push(grupo);
      usado[i] = true;
    }
    progreso.value = 100;
    gruposParecidas = grupos;
    paginaActualParecidas = 1;
    mostrarPaginaParecidas();
    btnBuscarParecidas.disabled = false;
    setTimeout(()=>{progreso.style.display='none';},1000);
  });

  // Hacer la función global para los botones de paginación
  window.mostrarPaginaParecidas = mostrarPaginaParecidas;

  function mostrarPaginaParecidas() {
    const totalPaginas = Math.ceil(gruposParecidas.length / gruposPorPagina);
    if (gruposParecidas.length === 0) {
      parecidasEl.innerHTML = '<b>No se encontraron líneas parecidas (ignorando fecha/hora).</b>';
      paginadoParecidasEl.innerHTML = '';
      return;
    }
    let html = '<h3>🔎 Líneas de código parecidas (ignorando fecha/hora):</h3>';
    const inicio = (paginaActualParecidas-1)*gruposPorPagina;
    const fin = Math.min(inicio+gruposPorPagina, gruposParecidas.length);
    for (let idx = inicio; idx < fin; idx++) {
      const grupo = gruposParecidas[idx];
      html += '<div style="margin-bottom:16px;padding:10px;border:1px solid #ddd;border-radius:6px;background:#fafafa">';
      html += `<div style='color:#065a9d;font-weight:bold'>${escapeHtml(grupo[0].norm)}</div>`;
      html += '<ul style="margin:8px 0 0 16px">';
      for (let obj of grupo) {
        html += `<li><span style='color:#888'>[${escapeHtml(obj.file)}]</span> ${escapeHtml(obj.raw)}</li>`;
      }
      html += '</ul></div>';
    }
    parecidasEl.innerHTML = html;
    // Controles de paginado
    let pagHtml = '';
    if (totalPaginas > 1) {
      pagHtml += `<button ${paginaActualParecidas===1?'disabled':''} onclick='window.mostrarPaginaParecidasNav(-1)'>Anterior</button> `;
      pagHtml += `Página ${paginaActualParecidas} de ${totalPaginas} `;
      pagHtml += `<button ${paginaActualParecidas===totalPaginas?'disabled':''} onclick='window.mostrarPaginaParecidasNav(1)'>Siguiente</button>`;
    }
    paginadoParecidasEl.innerHTML = pagHtml;
  }

  window.mostrarPaginaParecidasNav = function(delta) {
    const totalPaginas = Math.ceil(gruposParecidas.length / gruposPorPagina);
    paginaActualParecidas += delta;
    if (paginaActualParecidas < 1) paginaActualParecidas = 1;
    if (paginaActualParecidas > totalPaginas) paginaActualParecidas = totalPaginas;
    mostrarPaginaParecidas();
  }

  function normalizarLinea(linea) {
    return linea
      // Eliminar fechas tipo 2025-08-15, 15/08/2025, 2025/08/15, etc
      .replace(/\b\d{4}[-\/]\d{2}[-\/]\d{2}\b/g, '')
      .replace(/\b\d{2}[\/\-]\d{2}[\/\-]\d{4}\b/g, '')
      // Eliminar horas tipo 12:34:56 y 12:34
      .replace(/\b\d{2}:\d{2}:\d{2}\b/g, '')
      .replace(/\b\d{2}:\d{2}\b/g, '')
      // Eliminar cualquier número (entero o decimal)
      .replace(/\b\d+(\.\d+)?\b/g, '')
      // Eliminar años sueltos
      .replace(/\b\d{4}\b/g, '')
      // Espacios extra
      .replace(/\s+/g, ' ')
      .trim();
  }

  function sonSimilares(a, b) {
    if (!a || !b) return false;
    if (a === b) return false;
    let dist = levenshtein(a, b);
    let maxLen = Math.max(a.length, b.length);
    return dist <= Math.floor(maxLen * 0.3);
  }

  function levenshtein(a, b) {
    const matrix = [];
    let i;
    for (i = 0; i <= b.length; i++) { matrix[i] = [i]; }
    let j;
    for (j = 0; j <= a.length; j++) { matrix[0][j] = j; }
    for (i = 1; i <= b.length; i++) {
      for (j = 1; j <= a.length; j++) {
        if (b.charAt(i - 1) === a.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1)
          );
        }
      }
    }
    return matrix[b.length][a.length];
  }

})();
</script>
</body>
</html>